/*
Copyright (c) 2025 Amazon.com, Inc. or its affiliates. All Rights Reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Written by the KLR Contributors (https://github.com/leanprover/KLR)
*/
#pragma once

// This file is automatically generated from KLR.
// Manual edits to this file will be overwritten.

#include "klir_common.hpp"

namespace klr {

// KLR.Core Abstract Syntax
struct Access;

struct Pos final {
  Nat line;
  Nat column;
  Option<Nat> lineEnd;
  Option<Nat> columnEnd;
  Option<String> filename;
};

struct Immediate {
  enum class Tag {
    reg = 1,
    pointer,
    int32,
    float32,
  };
  Tag tag;
  Immediate(Tag tag) : tag(tag) {}
};

struct ImmediateRegisterWrapper final : Immediate {
  Nat reg;
  ImmediateRegisterWrapper() : Immediate(Tag::reg) {}
};

struct ImmediatePointerWrapper final : Immediate {
  ImmediatePointerWrapper() : Immediate(Tag::pointer) {}
};

struct ImmediateIntWrapper final : Immediate {
  Int i;
  ImmediateIntWrapper() : Immediate(Tag::int32) {}
};

struct ImmediateFloatWrapper final : Immediate {
  Float f;
  ImmediateFloatWrapper() : Immediate(Tag::float32) {}
};

enum class Memory {
  hbm = 1,
  sbuf,
  psum,
  reg,
};

enum class Dtype {
  bfloat16 = 1,
  float8e3,
  float8e4,
  float8e5,
  float16,
  float32,
  float32r,
  int8,
  int16,
  int64,
  int32,
  uint8,
  uint16,
  uint32,
  uint64,
  float8_e4m3fn,
  float8_e5m2_x4,
  float8_e4m3fn_x4,
  float4_e2m1fn_x4,
};

struct Shape final {
  Nat parDim;
  List<Nat> freeDims;
};

struct Address final {
  String name;
  Memory memory;
  Nat parSize;
  Nat freeSize;
  Option<Nat> parOffset;
  Option<Nat> freeOffset;
  Bool isShared;
};

struct TensorName final {
  String name;
  Dtype dtype;
  Ptr<Shape> shape;
  Ptr<Address> address;
  Nat freeElements;
  Prop parWF;
  Prop freeWF;
  Bool addressRotation;
};

struct Slice final {
  Nat l;
  Nat u;
  Int step;
  Prop wf;
};

struct Index {
  enum class Tag {
    coord = 1,
    slice,
  };
  Tag tag;
  Index(Tag tag) : tag(tag) {}
};

struct IndexCoordWrapper final : Index {
  Nat e;
  IndexCoordWrapper() : Index(Tag::coord) {}
};

struct IndexSliceWrapper final : Index {
  Ptr<Slice> slice;
  IndexSliceWrapper() : Index(Tag::slice) {}
};

struct AccessBasic final {
  Ptr<TensorName> tensor;
  List<Ptr<Index>> indexes;
  Prop lenWF;
};

struct APPair final {
  Int step;
  Nat num;
  Nat offset;
};

struct AccessPattern final {
  Ptr<TensorName> tensor;
  Nat parNum;
  List<Ptr<APPair>> pattern;
  Nat parOffset;
  Nat freeOffset;
  List<Nat> fixedAxis;
};

struct ScalarOffset {
  enum class Tag {
    reg = 1,
    acc,
  };
  Tag tag;
  ScalarOffset(Tag tag) : tag(tag) {}
};

struct ScalarOffsetRegWrapper final : ScalarOffset {
  String r;
  ScalarOffsetRegWrapper() : ScalarOffset(Tag::reg) {}
};

struct ScalarOffsetAccWrapper final : ScalarOffset {
  Ptr<Access> a;
  ScalarOffsetAccWrapper() : ScalarOffset(Tag::acc) {}
};

struct BirAccessPattern final {
  Ptr<TensorName> tensor;
  Nat offset;
  List<Ptr<APPair>> pattern;
  Option<Ptr<ScalarOffset>> scalarOffset;
  Option<Ptr<Access>> vectorOffset;
  Int indirectDim;
};

struct Access {
  enum class Tag {
    simple = 1,
    basic,
    pattern,
    birPattern,
  };
  Tag tag;
  Access(Tag tag) : tag(tag) {}
};

struct AccessSimpleWrapper final : Access {
  Ptr<TensorName> tensor;
  AccessSimpleWrapper() : Access(Tag::simple) {}
};

struct AccessBasicWrapper final : Access {
  Ptr<AccessBasic> access;
  AccessBasicWrapper() : Access(Tag::basic) {}
};

struct AccessPatternWrapper final : Access {
  Ptr<AccessPattern> access;
  AccessPatternWrapper() : Access(Tag::pattern) {}
};

struct AccessBirPatternWrapper final : Access {
  Ptr<BirAccessPattern> access;
  AccessBirPatternWrapper() : Access(Tag::birPattern) {}
};

struct TensorHbm final {
  String name;
  Dtype dtype;
  Nat address;
  List<Ptr<APPair>> dims;
};

struct TensorSram final {
  String name;
  Dtype dtype;
  Nat parNum;
  List<Ptr<APPair>> pattern;
  Nat parOffset;
  Nat freeOffset;
};

struct TensorRef {
  enum class Tag {
    abstract = 1,
    sbuf,
    psum,
    hbm,
    reg,
  };
  Tag tag;
  TensorRef(Tag tag) : tag(tag) {}
};

struct TensorRefAbstractWrapper final : TensorRef {
  Ptr<Access> access;
  TensorRefAbstractWrapper() : TensorRef(Tag::abstract) {}
};

struct TensorRefSbufWrapper final : TensorRef {
  Ptr<TensorSram> view;
  TensorRefSbufWrapper() : TensorRef(Tag::sbuf) {}
};

struct TensorRefPsumWrapper final : TensorRef {
  Ptr<TensorSram> view;
  TensorRefPsumWrapper() : TensorRef(Tag::psum) {}
};

struct TensorRefHbmWrapper final : TensorRef {
  Ptr<TensorHbm> view;
  TensorRefHbmWrapper() : TensorRef(Tag::hbm) {}
};

struct TensorRefRegisterWrapper final : TensorRef {
  Nat reg;
  TensorRefRegisterWrapper() : TensorRef(Tag::reg) {}
};

enum class MatmulPerfMode {
  None = 1,
  DoubleRow,
  DoubleRowSwInterleave,
};

enum class Engine {
  unassigned = 1,
  act,
  dma,
  dve,
  pe,
  pool,
  sp,
};

struct ActivationImm {
  enum class Tag {
    reg = 1,
    pointer,
    float32,
  };
  Tag tag;
  ActivationImm(Tag tag) : tag(tag) {}
};

struct ActivationImmRegisterWrapper final : ActivationImm {
  Nat reg;
  ActivationImmRegisterWrapper() : ActivationImm(Tag::reg) {}
};

struct ActivationImmPointerWrapper final : ActivationImm {
  ActivationImmPointerWrapper() : ActivationImm(Tag::pointer) {}
};

struct ActivationImmFloatWrapper final : ActivationImm {
  Float f;
  ActivationImmFloatWrapper() : ActivationImm(Tag::float32) {}
};

struct Operand {
  enum class Tag {
    imm = 1,
    tile,
  };
  Tag tag;
  Operand(Tag tag) : tag(tag) {}
};

struct OperandImmWrapper final : Operand {
  Ptr<Immediate> i;
  OperandImmWrapper() : Operand(Tag::imm) {}
};

struct OperandTileWrapper final : Operand {
  Ptr<TensorRef> t;
  OperandTileWrapper() : Operand(Tag::tile) {}
};

struct DataPattern final {
  Int offset;
  List<Ptr<APPair>> pattern;
  Int channelMultiplier;
};

enum class AluOp {
  abs = 1,
  add,
  arith_shift_left,
  arith_shift_right,
  average,
  bitwise_and,
  bitwise_not,
  bitwise_or,
  bitwise_xor,
  bypass,
  divide,
  is_equal,
  is_ge,
  is_gt,
  is_le,
  is_lt,
  logical_and,
  logical_or,
  logical_shift_left,
  logical_shift_right,
  logical_xor,
  max,
  min,
  mod,
  mult,
  not_equal,
  pow,
  rsqrt,
  subtract,
};

enum class DropoutThresholdType {
  DropRate = 1,
  KeepRate,
};

enum class AccumCmd {
  Idle = 1,
  Zero,
  Accumulate,
  ZeroAccumulate,
  LoadAccumulate,
};

enum class ActivationFunc {
  abs = 1,
  arctan,
  copy,
  erf,
  erf_dx,
  exp,
  gelu,
  gelu_apprx_tanh,
  gelu_dx,
  log,
  mish,
  reciprocal,
  relu,
  rsqrt,
  sigmoid,
  sign,
  silu,
  silu_dx,
  sin,
  softplus,
  sqrt,
  square,
  tanh,
};

enum class AffineSelectCmp {
  GreaterThan = 1,
  GreaterThanEq,
  Eq,
  NotEq,
};

enum class DgeComputeOp {
  none = 1,
  add,
};

struct DmaBounds {
  enum class Tag {
    skip = 1,
    error,
    reg,
  };
  Tag tag;
  DmaBounds(Tag tag) : tag(tag) {}
};

struct DmaBoundsSkipWrapper final : DmaBounds {
  DmaBoundsSkipWrapper() : DmaBounds(Tag::skip) {}
};

struct DmaBoundsErrorWrapper final : DmaBounds {
  DmaBoundsErrorWrapper() : DmaBounds(Tag::error) {}
};

struct DmaBoundsRegWrapper final : DmaBounds {
  Nat reg;
  DmaBoundsRegWrapper() : DmaBounds(Tag::reg) {}
};

enum class MatmulGroupElement {
  first = 1,
  middle,
  last,
  whole,
};

struct IndexMissBehavior {
  enum class Tag {
    imm = 1,
    skip,
  };
  Tag tag;
  IndexMissBehavior(Tag tag) : tag(tag) {}
};

struct IndexMissBehaviorImmWrapper final : IndexMissBehavior {
  Ptr<Immediate> value;
  IndexMissBehaviorImmWrapper() : IndexMissBehavior(Tag::imm) {}
};

struct IndexMissBehaviorSkipWrapper final : IndexMissBehavior {
  IndexMissBehaviorSkipWrapper() : IndexMissBehavior(Tag::skip) {}
};

enum class TensorScalarReverseOps {
  none = 1,
  first,
  second,
  both,
};

enum class TensorSubDim {
  X = 1,
  XY,
  XYZ,
  XYZW,
};

enum class TransposeOps {
  None = 1,
  WZXY,
  WXZY,
  WYXZ,
  ZWYX,
  ZYWX,
  ZYXW,
  YXWZ,
  YXZW,
  YWZX,
  XWZY,
  XZYW,
  XYZW,
  XYWZ,
};

struct Dropout final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  DropoutThresholdType thresholdType;
  Ptr<Operand> threshold;
  Option<Dtype> dtype;
};

struct Activate final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  AccumCmd accumulatorCmd;
  ActivationFunc activationFunc;
  Ptr<Immediate> scale;
  Ptr<Immediate> bias;
  Ptr<Immediate> imm;
};

struct AffineSelect final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  AffineSelectCmp fillMode;
  Nat fillReg;
  Ptr<DataPattern> maskPattern;
};

struct DmaCopy final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  DgeComputeOp compute_op;
  Ptr<DmaBounds> dstBoundsCheck;
  Ptr<DmaBounds> srcBoundsCheck;
};

struct DmaTranspose final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  TransposeOps axes;
  Option<Dtype> dtype;
  Nat dgeMode;
};

struct Transpose final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Option<Dtype> dtype;
  Engine engine;
};

struct LoadMaskRegister final {
  Nat regNum;
};

struct Shuffle final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  List<Ptr<Immediate>> shuffleMask;
  Option<Dtype> dtype;
};

struct MemSet final {
  Ptr<TensorRef> dst;
  Ptr<Immediate> value;
  Dtype dtype;
  Engine engine;
};

struct Iota final {
  Ptr<TensorRef> dst;
  Ptr<DataPattern> pattern;
  Option<Dtype> dtype;
};

struct LoadStationary final {
  Ptr<TensorRef> src;
  Bool isTranspose;
};

struct MatMul final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> moving;
  MatmulGroupElement psumAccumulateFlag;
};

struct LocalGather final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<IndexMissBehavior> indexMissBehavior;
  Bool freePoolBuffer;
};

struct RangeSelect final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  AccumCmd reduceCommand;
  AluOp reduceOp;
  Float base;
  Float fillValue;
  AluOp compOp0;
  AluOp compOp1;
  Ptr<Immediate> bound0;
  Ptr<Immediate> bound1;
};

struct ScalarTensorTensor final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src0;
  Ptr<TensorRef> src1;
  AluOp op0;
  AluOp op1;
  TensorScalarReverseOps reverseOperands;
  Ptr<Immediate> imm0;
  AccumCmd accumulatorCmd;
};

struct CopyPredicated final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<TensorRef> predicate;
  Option<Dtype> dtype;
  Bool reversePred;
};

struct TensorTensorScan final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src0;
  Ptr<TensorRef> src1;
  AluOp op0;
  AluOp op1;
  TensorScalarReverseOps reverseOperands;
  Ptr<Operand> imm0;
  AccumCmd accumulatorCmd;
  Option<Dtype> dtype;
};

struct MatchValueLoad final {
  Ptr<TensorRef> src;
};

struct FindIndex8 final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<TensorRef> vals;
  Option<Dtype> dtype;
};

struct MatchReplace8 final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<TensorRef> vals;
  Ptr<Immediate> replaceValue;
  Option<Ptr<TensorRef>> dstIdx;
  Option<Dtype> dtype;
};

struct Max8 final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Option<Dtype> dtype;
};

struct BatchNormAggregate final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Option<Dtype> dtype;
};

struct BatchNormStats final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Option<Dtype> dtype;
};

struct Reciprocal final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Option<Dtype> dtype;
};

struct Copy final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Option<TensorSubDim> opDim;
};

struct TensorReduce final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  AluOp op;
  TensorSubDim opDim;
  Bool negated;
  Option<Dtype> dtype;
  Bool keepdims;
};

struct TensorScalar final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<Operand> imm0;
  AluOp op0;
  Option<Ptr<Operand>> imm1;
  Option<AluOp> op1;
  TensorScalarReverseOps reverse;
  Engine engine;
  Option<Dtype> dtype;
};

struct TensorTensor final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src0;
  Ptr<TensorRef> src1;
  AluOp op;
  Option<Dtype> dtype;
  Engine engine;
};

struct NcMatMul final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> stationary;
  Ptr<TensorRef> moving;
  Bool isStationaryOneZero;
  Bool isMovingZero;
  Bool isTranspose;
  List<Nat> tilePosition;
  List<Nat> tileSize;
  Nat psumAccumulateFlag;
  MatmulPerfMode perfMode;
};

struct TensorScalarReduce final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<Operand> operand0;
  AluOp op0;
  Bool reverse0;
  Option<Dtype> dtype;
  Option<AluOp> reduceOp;
  Ptr<TensorRef> reduceRes;
};

struct TensorPartitionReduce final {
  Ptr<TensorRef> dst;
  AluOp op;
  Ptr<TensorRef> data;
  Option<Dtype> dtype;
};

struct NcActivate final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  AccumCmd accumulatorCmd;
  ActivationFunc activationFunc;
  Ptr<Operand> scale;
  Option<Ptr<TensorRef>> bias;
  Option<AluOp> reduceOp;
  Option<Ptr<TensorRef>> reduceRes;
  Option<Dtype> dtype;
};

struct NcAffineSelect final {
  Ptr<TensorRef> dst;
  Ptr<DataPattern> pred;
  Ptr<TensorRef> onTrueTile;
  Ptr<Immediate> onFalseValue;
  Option<Dtype> dtype;
  AluOp cmpOp;
};

struct NcDmaCopy final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  DgeComputeOp compute_op;
  Ptr<DmaBounds> oobMode;
  Nat dgeMode;
  Bool uniqueIndices;
  Engine engine;
};

struct NcLocalGather final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<TensorRef> index;
  Ptr<Immediate> numElemPerIdx;
  Option<Ptr<Immediate>> numValidIndicies;
};

struct NcRangeSelect final {
  Ptr<TensorRef> dst;
  AccumCmd reduceCommand;
  Option<Ptr<TensorRef>> reduceRes;
  Option<AluOp> reduceOp;
  AluOp compOp0;
  AluOp compOp1;
  Ptr<TensorRef> bound0;
  Ptr<TensorRef> bound1;
  Ptr<Immediate> rangeStart;
  Ptr<TensorRef> onTrueTile;
  Ptr<Immediate> onFalseValue;
  Option<Dtype> dtype;
};

struct NcScalarTensorTensor final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> data;
  Ptr<Operand> src0;
  Ptr<Operand> src1;
  AluOp op0;
  AluOp op1;
  TensorScalarReverseOps reverseOperands;
  Option<Dtype> dtype;
};

struct NcCopy final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Option<Dtype> dtype;
  Engine engine;
};

struct SelectReduce final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> predicate;
  Ptr<TensorRef> onTrue;
  Ptr<Operand> onFalse;
  Option<Ptr<TensorRef>> reduceRes;
  AccumCmd reduceCmd;
  AluOp reduceOp;
  Bool reversePred;
  Option<Dtype> dtype;
};

struct SequenceBounds final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> segmentIds;
  Option<Dtype> dtype;
};

struct SendRecv final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<Immediate> sendToRank;
  Ptr<Immediate> recvFromRank;
  Ptr<Immediate> pipeId;
  Bool useGpsimdDma;
};

struct SendRecvCCE final {
  Ptr<TensorRef> dst;
  List<Ptr<TensorRef>> src;
  Ptr<Immediate> sendToRank;
  List<Ptr<Immediate>> recvFromRanks;
  Ptr<Immediate> pipeId;
  AluOp op;
};

struct QuantizeMX final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  Ptr<TensorRef> dstScale;
};

struct MatMulMX final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> stationary;
  Ptr<TensorRef> moving;
  Ptr<TensorRef> stationaryScale;
  Ptr<TensorRef> movingScale;
  Nat psumAccumulateFlag;
  Option<List<Nat>> tilePosition;
  Option<List<Nat>> tileSize;
};

struct DmaCompute final {
  Ptr<TensorRef> dst;
  List<Ptr<TensorRef>> srcs;
  List<Ptr<Immediate>> scales;
  AluOp reduceOp;
};

struct CollectiveOp final {
  List<Ptr<TensorRef>> dsts;
  List<Ptr<TensorRef>> srcs;
  Option<AluOp> op;
  Option<List<List<Int>>> replicaGroups;
  Option<Int> reduceScatterDim;
  Option<Int> allGatherDim;
  Option<List<List<Int>>> sourceTargetPairs;
  Option<List<Int>> broacastSizes;
  Option<Int> splitDim;
  Option<Int> concatDim;
};

struct Send final {
  AluOp op;
  List<Ptr<TensorRef>> srcs;
  Int peerId;
};

struct Recv final {
  AluOp op;
  List<Ptr<TensorRef>> dsts;
  List<Int> replicaGroups;
  Int peerId;
};

enum class BrCmpOp {
  always = 1,
  lt_imm,
  le_imm,
  eq_imm,
  ne_imm,
  ge_imm,
  gt_imm,
  lt_reg,
  le_reg,
  eq_reg,
  ne_reg,
  ge_reg,
  gt_reg,
};

struct TensorLoad final {
  String dst;
  Ptr<TensorRef> src;
};

struct TensorStore final {
  Ptr<TensorRef> dst;
  String src;
};

struct RegisterMove final {
  String dst;
  Int imm;
};

struct CmpBranch final {
  String reg1;
  String reg2;
  Int imm;
  BrCmpOp op;
  String trueLabel;
  String falseLabel;
};

struct RegisterAluOp final {
  String dst;
  String src;
  Int imm;
  AluOp op;
};

struct CoreBarrier final {
  Ptr<TensorRef> data;
  List<Int> cores;
  Engine engine;
};

struct Rng final {
  Ptr<TensorRef> dst;
  Engine engine;
};

struct Rand2 final {
  Ptr<TensorRef> dst;
  Ptr<Operand> min;
  Ptr<Operand> max;
};

struct RandGetState final {
  Ptr<TensorRef> dst;
  Engine engine;
};

struct SetRngSeed final {
  Ptr<TensorRef> src;
};

struct RandSetState final {
  Ptr<TensorRef> src;
  Engine engine;
};

struct ExtendedInst final {
  Nat opcode;
  Bool hasRead;
  Bool hasWrite;
  Nat ports;
  List<Nat> data0;
  List<Nat> data1;
};

struct TensorScalarCumulative final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> src;
  AluOp op0;
  AluOp op1;
  Ptr<Operand> imm0;
  Option<Ptr<Operand>> imm1;
  AccumCmd reduceCmd;
  TensorScalarReverseOps reverse;
  Option<Dtype> dtype;
};

struct NcNGather final {
  Ptr<TensorRef> dst;
  Ptr<TensorRef> data;
  Ptr<TensorRef> indices;
  Option<Dtype> dtype;
};

struct Operator {
  enum class Tag {
    activate = 1,
    ncActivate,
    activationReduce,
    affineSelect,
    ncAffineSelect,
    batchNormAggregate,
    batchNormStats,
    copy,
    ncCopy,
    copyPredicated,
    dmaCopy,
    ncDmaCopy,
    dmaTranspose,
    dropout,
    findIndex8,
    iota,
    loadMaskRegister,
    loadStationary,
    localGather,
    ncLocalGather,
    matMul,
    ncMatMul,
    matchReplace8,
    matchValueLoad,
    max8,
    memSet,
    rangeSelect,
    ncRangeSelect,
    reciprocal,
    scalarTensorTensor,
    ncScalarTensorTensor,
    shuffle,
    tensorReduce,
    tensorScalar,
    tensorTensor,
    tensorTensorScan,
    tensorPartitionReduce,
    tensorScalarReduce,
    transpose,
    selectReduce,
    sequenceBounds,
    sendRecv,
    sendRecvCCE,
    tensorLoad,
    tensorStore,
    registerMove,
    cmpBranch,
    registerAluOp,
    quantizeMX,
    ncMatMulMX,
    dmaCompute,
    allReduce,
    allGather,
    reduceScatter,
    collectivePermute,
    broadcast,
    allToAll,
    send,
    recv,
    coreBarrier,
    rng,
    rand2,
    randGetState,
    setRngSeed,
    randSetState,
    extendedInst,
    tensorScalarCumulative,
    ncNGather,
  };
  Tag tag;
  Operator(Tag tag) : tag(tag) {}
};

struct OperatorActivateWrapper final : Operator {
  Ptr<Activate> op;
  OperatorActivateWrapper() : Operator(Tag::activate) {}
};

struct OperatorNcActivateWrapper final : Operator {
  Ptr<NcActivate> op;
  OperatorNcActivateWrapper() : Operator(Tag::ncActivate) {}
};

struct OperatorActivationReduceWrapper final : Operator {
  Ptr<NcActivate> op;
  OperatorActivationReduceWrapper() : Operator(Tag::activationReduce) {}
};

struct OperatorAffineSelectWrapper final : Operator {
  Ptr<AffineSelect> op;
  OperatorAffineSelectWrapper() : Operator(Tag::affineSelect) {}
};

struct OperatorNcAffineSelectWrapper final : Operator {
  Ptr<NcAffineSelect> op;
  OperatorNcAffineSelectWrapper() : Operator(Tag::ncAffineSelect) {}
};

struct OperatorBatchNormAggregateWrapper final : Operator {
  Ptr<BatchNormAggregate> op;
  OperatorBatchNormAggregateWrapper() : Operator(Tag::batchNormAggregate) {}
};

struct OperatorBatchNormStatsWrapper final : Operator {
  Ptr<BatchNormStats> op;
  OperatorBatchNormStatsWrapper() : Operator(Tag::batchNormStats) {}
};

struct OperatorCopyWrapper final : Operator {
  Ptr<Copy> op;
  OperatorCopyWrapper() : Operator(Tag::copy) {}
};

struct OperatorNcCopyWrapper final : Operator {
  Ptr<NcCopy> op;
  OperatorNcCopyWrapper() : Operator(Tag::ncCopy) {}
};

struct OperatorCopyPredicatedWrapper final : Operator {
  Ptr<CopyPredicated> op;
  OperatorCopyPredicatedWrapper() : Operator(Tag::copyPredicated) {}
};

struct OperatorDmaCopyWrapper final : Operator {
  Ptr<DmaCopy> op;
  OperatorDmaCopyWrapper() : Operator(Tag::dmaCopy) {}
};

struct OperatorNcDmaCopyWrapper final : Operator {
  Ptr<NcDmaCopy> op;
  OperatorNcDmaCopyWrapper() : Operator(Tag::ncDmaCopy) {}
};

struct OperatorDmaTransposeWrapper final : Operator {
  Ptr<DmaTranspose> op;
  OperatorDmaTransposeWrapper() : Operator(Tag::dmaTranspose) {}
};

struct OperatorDropoutWrapper final : Operator {
  Ptr<Dropout> op;
  OperatorDropoutWrapper() : Operator(Tag::dropout) {}
};

struct OperatorFindIndex8Wrapper final : Operator {
  Ptr<FindIndex8> op;
  OperatorFindIndex8Wrapper() : Operator(Tag::findIndex8) {}
};

struct OperatorIotaWrapper final : Operator {
  Ptr<Iota> op;
  OperatorIotaWrapper() : Operator(Tag::iota) {}
};

struct OperatorLoadMaskRegisterWrapper final : Operator {
  Ptr<LoadMaskRegister> op;
  OperatorLoadMaskRegisterWrapper() : Operator(Tag::loadMaskRegister) {}
};

struct OperatorLoadStationaryWrapper final : Operator {
  Ptr<LoadStationary> op;
  OperatorLoadStationaryWrapper() : Operator(Tag::loadStationary) {}
};

struct OperatorLocalGatherWrapper final : Operator {
  Ptr<LocalGather> op;
  OperatorLocalGatherWrapper() : Operator(Tag::localGather) {}
};

struct OperatorNcLocalGatherWrapper final : Operator {
  Ptr<NcLocalGather> op;
  OperatorNcLocalGatherWrapper() : Operator(Tag::ncLocalGather) {}
};

struct OperatorMatMulWrapper final : Operator {
  Ptr<MatMul> op;
  OperatorMatMulWrapper() : Operator(Tag::matMul) {}
};

struct OperatorNcMatMulWrapper final : Operator {
  Ptr<NcMatMul> op;
  OperatorNcMatMulWrapper() : Operator(Tag::ncMatMul) {}
};

struct OperatorMatchReplace8Wrapper final : Operator {
  Ptr<MatchReplace8> op;
  OperatorMatchReplace8Wrapper() : Operator(Tag::matchReplace8) {}
};

struct OperatorMatchValueLoadWrapper final : Operator {
  Ptr<MatchValueLoad> op;
  OperatorMatchValueLoadWrapper() : Operator(Tag::matchValueLoad) {}
};

struct OperatorMax8Wrapper final : Operator {
  Ptr<Max8> op;
  OperatorMax8Wrapper() : Operator(Tag::max8) {}
};

struct OperatorMemSetWrapper final : Operator {
  Ptr<MemSet> op;
  OperatorMemSetWrapper() : Operator(Tag::memSet) {}
};

struct OperatorRangeSelectWrapper final : Operator {
  Ptr<RangeSelect> op;
  OperatorRangeSelectWrapper() : Operator(Tag::rangeSelect) {}
};

struct OperatorNcRangeSelectWrapper final : Operator {
  Ptr<NcRangeSelect> op;
  OperatorNcRangeSelectWrapper() : Operator(Tag::ncRangeSelect) {}
};

struct OperatorReciprocalWrapper final : Operator {
  Ptr<Reciprocal> op;
  OperatorReciprocalWrapper() : Operator(Tag::reciprocal) {}
};

struct OperatorScalarTensorTensorWrapper final : Operator {
  Ptr<ScalarTensorTensor> op;
  OperatorScalarTensorTensorWrapper() : Operator(Tag::scalarTensorTensor) {}
};

struct OperatorNcScalarTensorTensorWrapper final : Operator {
  Ptr<NcScalarTensorTensor> op;
  OperatorNcScalarTensorTensorWrapper() : Operator(Tag::ncScalarTensorTensor) {}
};

struct OperatorShuffleWrapper final : Operator {
  Ptr<Shuffle> op;
  OperatorShuffleWrapper() : Operator(Tag::shuffle) {}
};

struct OperatorTensorReduceWrapper final : Operator {
  Ptr<TensorReduce> op;
  OperatorTensorReduceWrapper() : Operator(Tag::tensorReduce) {}
};

struct OperatorTensorScalarWrapper final : Operator {
  Ptr<TensorScalar> op;
  OperatorTensorScalarWrapper() : Operator(Tag::tensorScalar) {}
};

struct OperatorTensorTensorWrapper final : Operator {
  Ptr<TensorTensor> op;
  OperatorTensorTensorWrapper() : Operator(Tag::tensorTensor) {}
};

struct OperatorTensorTensorScanWrapper final : Operator {
  Ptr<TensorTensorScan> op;
  OperatorTensorTensorScanWrapper() : Operator(Tag::tensorTensorScan) {}
};

struct OperatorTensorPartitionReduceWrapper final : Operator {
  Ptr<TensorPartitionReduce> op;
  OperatorTensorPartitionReduceWrapper()
      : Operator(Tag::tensorPartitionReduce) {}
};

struct OperatorTensorScalarReduceWrapper final : Operator {
  Ptr<TensorScalarReduce> op;
  OperatorTensorScalarReduceWrapper() : Operator(Tag::tensorScalarReduce) {}
};

struct OperatorTransposeWrapper final : Operator {
  Ptr<Transpose> op;
  OperatorTransposeWrapper() : Operator(Tag::transpose) {}
};

struct OperatorSelectReduceWrapper final : Operator {
  Ptr<SelectReduce> op;
  OperatorSelectReduceWrapper() : Operator(Tag::selectReduce) {}
};

struct OperatorSequenceBoundsWrapper final : Operator {
  Ptr<SequenceBounds> op;
  OperatorSequenceBoundsWrapper() : Operator(Tag::sequenceBounds) {}
};

struct OperatorSendRecvWrapper final : Operator {
  Ptr<SendRecv> op;
  OperatorSendRecvWrapper() : Operator(Tag::sendRecv) {}
};

struct OperatorSendRecvCCEWrapper final : Operator {
  Ptr<SendRecvCCE> op;
  OperatorSendRecvCCEWrapper() : Operator(Tag::sendRecvCCE) {}
};

struct OperatorTensorLoadWrapper final : Operator {
  Ptr<TensorLoad> op;
  OperatorTensorLoadWrapper() : Operator(Tag::tensorLoad) {}
};

struct OperatorTensorStoreWrapper final : Operator {
  Ptr<TensorStore> op;
  OperatorTensorStoreWrapper() : Operator(Tag::tensorStore) {}
};

struct OperatorRegisterMoveWrapper final : Operator {
  Ptr<RegisterMove> op;
  OperatorRegisterMoveWrapper() : Operator(Tag::registerMove) {}
};

struct OperatorCmpBranchWrapper final : Operator {
  Ptr<CmpBranch> op;
  OperatorCmpBranchWrapper() : Operator(Tag::cmpBranch) {}
};

struct OperatorRegisterAluOpWrapper final : Operator {
  Ptr<RegisterAluOp> op;
  OperatorRegisterAluOpWrapper() : Operator(Tag::registerAluOp) {}
};

struct OperatorQuantizeMXWrapper final : Operator {
  Ptr<QuantizeMX> op;
  OperatorQuantizeMXWrapper() : Operator(Tag::quantizeMX) {}
};

struct OperatorNcMatMulMXWrapper final : Operator {
  Ptr<MatMulMX> op;
  OperatorNcMatMulMXWrapper() : Operator(Tag::ncMatMulMX) {}
};

struct OperatorDmaComputeWrapper final : Operator {
  Ptr<DmaCompute> op;
  OperatorDmaComputeWrapper() : Operator(Tag::dmaCompute) {}
};

struct OperatorAllReduceWrapper final : Operator {
  Ptr<CollectiveOp> op;
  OperatorAllReduceWrapper() : Operator(Tag::allReduce) {}
};

struct OperatorAllGatherWrapper final : Operator {
  Ptr<CollectiveOp> op;
  OperatorAllGatherWrapper() : Operator(Tag::allGather) {}
};

struct OperatorReduceScatterWrapper final : Operator {
  Ptr<CollectiveOp> op;
  OperatorReduceScatterWrapper() : Operator(Tag::reduceScatter) {}
};

struct OperatorCollectivePermuteWrapper final : Operator {
  Ptr<CollectiveOp> op;
  OperatorCollectivePermuteWrapper() : Operator(Tag::collectivePermute) {}
};

struct OperatorBroadcastWrapper final : Operator {
  Ptr<CollectiveOp> op;
  OperatorBroadcastWrapper() : Operator(Tag::broadcast) {}
};

struct OperatorAllToAllWrapper final : Operator {
  Ptr<CollectiveOp> op;
  OperatorAllToAllWrapper() : Operator(Tag::allToAll) {}
};

struct OperatorSendWrapper final : Operator {
  Ptr<Send> op;
  OperatorSendWrapper() : Operator(Tag::send) {}
};

struct OperatorRecvWrapper final : Operator {
  Ptr<Recv> op;
  OperatorRecvWrapper() : Operator(Tag::recv) {}
};

struct OperatorCoreBarrierWrapper final : Operator {
  Ptr<CoreBarrier> op;
  OperatorCoreBarrierWrapper() : Operator(Tag::coreBarrier) {}
};

struct OperatorRngWrapper final : Operator {
  Ptr<Rng> op;
  OperatorRngWrapper() : Operator(Tag::rng) {}
};

struct OperatorRand2Wrapper final : Operator {
  Ptr<Rand2> op;
  OperatorRand2Wrapper() : Operator(Tag::rand2) {}
};

struct OperatorRandGetStateWrapper final : Operator {
  Ptr<RandGetState> op;
  OperatorRandGetStateWrapper() : Operator(Tag::randGetState) {}
};

struct OperatorSetRngSeedWrapper final : Operator {
  Ptr<SetRngSeed> op;
  OperatorSetRngSeedWrapper() : Operator(Tag::setRngSeed) {}
};

struct OperatorRandSetStateWrapper final : Operator {
  Ptr<RandSetState> op;
  OperatorRandSetStateWrapper() : Operator(Tag::randSetState) {}
};

struct OperatorExtendedInstWrapper final : Operator {
  Ptr<ExtendedInst> op;
  OperatorExtendedInstWrapper() : Operator(Tag::extendedInst) {}
};

struct OperatorTensorScalarCumulativeWrapper final : Operator {
  Ptr<TensorScalarCumulative> op;
  OperatorTensorScalarCumulativeWrapper()
      : Operator(Tag::tensorScalarCumulative) {}
};

struct OperatorNcNGatherWrapper final : Operator {
  Ptr<NcNGather> op;
  OperatorNcNGatherWrapper() : Operator(Tag::ncNGather) {}
};

struct Stmt {
  enum class Tag {
    oper = 1,
  };
  Tag tag;
  Stmt(Tag tag) : tag(tag) {}
};

struct StmtOperWrapper final : Stmt {
  Ptr<Operator> op;
  Option<String> name;
  Ptr<Pos> pos;
  StmtOperWrapper() : Stmt(Tag::oper) {}
};

struct Block final {
  String label;
  List<Ptr<Stmt>> body;
};

struct Kernel final {
  String name;
  List<Ptr<TensorName>> inputs;
  List<Ptr<TensorName>> outputs;
  List<Ptr<Block>> body;
};

struct SharedConstantFile final {
  String name;
  String fileName;
};

struct Edges final {
  String fromEdge;
  List<String> toEdges;
};

struct LncKernel final {
  String name;
  List<Ptr<TensorName>> inputs;
  List<Ptr<TensorName>> outputs;
  List<List<Ptr<Block>>> bodies;
  List<Ptr<SharedConstantFile>> sharedConstants;
  List<Ptr<Edges>> edges;
};

struct KLRFile final {
  Nat major;
  Nat minor;
  Nat patch;
};

struct KLRMetaData final {
  String format;
};

struct Contents {
  enum class Tag {
    python = 1,
    nki,
    kernel,
    lnc,
    hlo,
  };
  Tag tag;
  Contents(Tag tag) : tag(tag) {}
};

struct ContentsPythonWrapper final : Contents {
  Ptr<Kernel> kernel;
  ContentsPythonWrapper() : Contents(Tag::python) {}
};

struct ContentsNkiWrapper final : Contents {
  Ptr<Kernel> kernel;
  ContentsNkiWrapper() : Contents(Tag::nki) {}
};

struct ContentsKernelWrapper final : Contents {
  Ptr<Kernel> kernel;
  ContentsKernelWrapper() : Contents(Tag::kernel) {}
};

struct ContentsLncWrapper final : Contents {
  Ptr<LncKernel> kernel;
  ContentsLncWrapper() : Contents(Tag::lnc) {}
};

struct ContentsHloWrapper final : Contents {
  String name;
  ContentsHloWrapper() : Contents(Tag::hlo) {}
};
} // namespace klr
